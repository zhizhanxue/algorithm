package 动态规划.硬币面值组合问题_518;
//给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。
//
// 示例 1: 
//
// 输入: amount = 5, coins = [1, 2, 5]
//输出: 4
//解释: 有四种方式可以凑成总金额:
//5=5
//5=2+2+1
//5=2+1+1+1
//5=1+1+1+1+1
// 
//
// 示例 2: 
//
// 输入: amount = 3, coins = [2]
//输出: 0
//解释: 只用面额2的硬币不能凑成总金额3。
// 
//
// 示例 3: 
//
// 输入: amount = 10, coins = [10] 
//输出: 1
// 
//
// 
//
// 注意: 
//
// 你可以假设： 
//
// 
// 0 <= amount (总金额) <= 5000 
// 1 <= coin (硬币面额) <= 5000 
// 硬币种类不超过 500 种 
// 结果符合 32 位符号整数 
// 
// 👍 275 👎 0

class Solution {
    //Time:O(m * n)     Space:O(n)
    public int change(int amount, int[] coins) {
        int m = coins.length;
        int[] dp = new int[amount + 1];
        dp[0] = 1;
        for (int i = 1; i <= m; i++){
            for(int j = coins[i-1]; j <= amount; j++){
                dp[j] += dp[j-coins[i-1]];
            }
        }
        return dp[amount];
    }
    //完全背包问题
    //dp(i,j)看作前i个硬币组成总金额为j的方案个数
    //dp[i][j] = dp[i-1][j] + dp[i][j-coins[i-1]]  dp[i-1][j]:不用第i个硬币的方案个数,至少用一个第i个硬币的方案个数
    //初始化状态，1<=i<=coins.length;  dp[i][0] = 1
    //  初始化状态的解释:
    //              1.用前i 个硬币组成金额为0的方案个数为1 .输入: amount = 5, coins = [1, 2, 5]
    //              2.i=1,j=0, dp[1][0] 对应 0 * 1
    //              3.i=2,j=0  dp[2][0] 对应 0 * 1 + 0 * 2
    //              4.i=3,j=0  dp[3][0] 对应 0 * 1 + 0 * 2 + 0 * 5
    //              以上dp[i][0]都对应一种方案而dp[0][i]的状态是不使用硬币去组成对应金额的方案,不合理，故为0

    //状态优化
    //dp[i][j] = dp[i-1][j] + dp[i][j-coins[i-1]]
    //dp[j] = j >= coins[i-1] ? dp[j] : dp[j] + dp[j-coins[i-1]]
    //因为在二维数组里，当前状态只依赖上一层同一列的状态和本层前置列的状态，故可进行优化空间
}